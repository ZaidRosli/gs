/* Compiler library  */
#include "scan.h"
#include <stdio.h>

extern FILE *out_fp;  // Declare an external file pointer for output operations.

void outlib(void) {
    // Print the utility functions and their assembly-like handlers to the output file.
    fprintf(out_fp,
        "; ------------------------\n"
        "; Utility functions\n"
        "; ------------------------\n"
        "EOVF            CALL    WRITELINE\n"
        "                LAD     gr1, EOVF1\n"
        "                LD      gr2, gr0\n"
        "                CALL    WRITESTR\n"
        "                CALL    WRITELINE\n"
        "                SVC     1  ;  Handle overflow errors\n"
        "EOVF1           DC      '***** Run-Time Error : Overflow *****'\n"
        "E0DIV           JNZ     EOVF\n"
        "                CALL    WRITELINE\n"
        "                LAD     gr1, E0DIV1\n"
        "                LD      gr2, gr0\n"
        "                CALL    WRITESTR\n"
        "                CALL    WRITELINE\n"
        "                SVC     2  ;  Handle zero-divide errors\n"
        "E0DIV1          DC      '***** Run-Time Error : Zero-Divide *****'\n"
        "EROV            CALL    WRITELINE\n"
        "                LAD     gr1, EROV1\n"
        "                LD      gr2, gr0\n"
        "                CALL    WRITESTR\n"
        "                CALL    WRITELINE\n"
        "                SVC     3  ;  Handle range-over errors\n"
        "EROV1           DC      '***** Run-Time Error : Range-Over in Array Index *****'\n"

        // Write character function to handle outputting a single character with optional padding.
        "WRITECHAR       RPUSH\n"
        "                LD      gr6, SPACE\n"
        "                LD      gr7, OBUFSIZE\n"
        "WC1             SUBA    gr2, ONE  ; Loop to handle padding with spaces\n"
        "                JZE     WC2\n"
        "                JMI     WC2\n"
        "                ST      gr6, OBUF,gr7  ; Output space as padding\n"
        "                CALL    BOVFCHECK\n"
        "                JUMP    WC1\n"
        "WC2             ST      gr1, OBUF,gr7  ; Output the actual character\n"
        "                CALL    BOVFCHECK\n"
        "                ST      gr7, OBUFSIZE\n"
        "                RPOP\n"
        "                RET\n"

        // Write string function to handle outputting a string with optional padding.
        "WRITESTR        RPUSH\n"
        "                LD      gr6, gr1  ; Start of the string\n"
        "WS1             LD      gr4, 0,gr6  ; Loop to iterate through the string\n"
        "                JZE     WS2\n"
        "                ADDA    gr6, ONE\n"
        "                SUBA    gr2, ONE\n"
        "                JUMP    WS1\n"
        "WS2             LD      gr7, OBUFSIZE  ; Prepare output buffer\n"
        "                LD      gr5, SPACE\n"
        "WS3             SUBA    gr2, ONE  ; Padding loop\n"
        "                JMI     WS4\n"
        "                ST      gr5, OBUF,gr7\n"
        "                CALL    BOVFCHECK\n"
        "                JUMP    WS3\n"
        "WS4             LD      gr4, 0,gr1  ; Output loop for string\n"
        "                JZE     WS5\n"
        "                ST      gr4, OBUF,gr7\n"
        "                ADDA    gr1, ONE\n"
        "                CALL    BOVFCHECK\n"
        "                JUMP    WS4\n"
        "WS5             ST      gr7, OBUFSIZE\n"
        "                RPOP\n"
        "                RET\n"

        // Buffer overflow check function.
        "BOVFCHECK       ADDA    gr7, ONE\n"
        "                CPA     gr7, BOVFLEVEL\n"
        "                JMI     BOVF1\n"
        "                CALL    WRITELINE\n"
        "                LD      gr7, OBUFSIZE\n"
        "BOVF1           RET\n"
        "BOVFLEVEL       DC      256\n"

        // Integer writing with space padding or zero-padding based on gr2.
        "WRITEINT        RPUSH\n"
        "                LD      gr7, gr0  ; Initialize flag to 0 (positive numbers).\n"
        "                CPA     gr1, gr0  ; Compare integer with zero.\n"
        "                JPL     WI1       ; If positive, process normally.\n"
        "                JZE     WI1       ; If zero, also process normally.\n"
        "                LD      gr4, gr0  ; Prepare to handle negative numbers.\n"
        "                SUBA    gr4, gr1  ; Negate the number.\n"
        "                CPA     gr4, gr1  ; Check for negation overflow (INT_MIN).\n"
        "                JZE     WI6       ; If overflow, handle INT_MIN specifically.\n"
        "                LD      gr1, gr4  ; Use negated number for further processing.\n"
        "                LD      gr7, ONE  ; Set flag to 1 (negative number).\n"
        "WI1             LD      gr6, SIX  ; Start at the end of the buffer.\n"
        "                ST      gr0, INTBUF,gr6  ; Null-terminate the string.\n"
        "                SUBA    gr6, ONE  ; Decrement to fill string from end to start.\n"
        "                CPA     gr1, gr0  ; Check if number is zero now.\n"
        "                JNZ     WI2       ; If not zero, convert number to string.\n"
        "                LD      gr4, ZERO ; Load ASCII '0'.\n"
        "                ST      gr4, INTBUF,gr6  ; Place '0' in the buffer.\n"
        "                JUMP    WI5       ; Skip conversion, print result.\n"
        "WI2             CPA     gr1, gr0  ; Loop to convert number to string.\n"
        "                JZE     WI3       ; If zero, end loop.\n"
        "                LD      gr5, gr1  ; Load current number.\n"
        "                DIVA    gr1, TEN  ; Divide by 10.\n"
        "                LD      gr4, gr1  ; Temporarily store quotient.\n"
        "                MULA    gr4, TEN  ; Multiply quotient by 10.\n"
        "                SUBA    gr5, gr4  ; Subtract to find remainder.\n"
        "                ADDA    gr5, ZERO ; Convert remainder to ASCII.\n"
        "                ST      gr5, INTBUF,gr6  ; Store character.\n"
        "                SUBA    gr6, ONE  ; Move to next position in buffer.\n"
        "                JUMP    WI2       ; Repeat for next digit.\n"
        "WI3             CPA     gr7, gr0  ; Check if the number was negative.\n"
        "                JZE     WI4       ; If not negative, do not add minus sign.\n"
        "                LD      gr4, MINUS; Load minus sign.\n"
        "                ST      gr4, INTBUF,gr6  ; Store minus sign in buffer.\n"
        "                JUMP    WI5       ; Proceed to output the string.\n"
        "WI4             ADDA    gr6, ONE  ; Adjust buffer index for positive numbers.\n"
        "WI5             LAD     gr1, INTBUF,gr6  ; Prepare pointer for output.\n"
        "                CALL    WRITESTR  ; Output the formatted integer string.\n"
        "                RPOP\n"
        "                RET\n"
        "WI6             LAD     gr1, MMINT; Handle INT_MIN specifically.\n"
        "                CALL    WRITESTR  ; Output the INT_MIN string.\n"
        "                RPOP\n"
        "                RET\n"
        "MMINT           DC      '-32768'  ; Define the smallest 32-bit integer value.\n"

        // Boolean value writing based on condition evaluation.
        "WRITEBOOL       RPUSH\n"
        "                CPA     gr1, gr0  ; Check if gr1 is zero.\n"
        "                JZE     WB1       ; If zero, set to 'FALSE'.\n"
        "                LAD     gr1, WBTRUE  ; Otherwise, set to 'TRUE'.\n"
        "                JUMP    WB2       ; Jump to write string function.\n"
        "WB1             LAD     gr1, WBFALSE ; Load 'FALSE' address.\n"
        "WB2             CALL    WRITESTR  ; Output 'TRUE' or 'FALSE'.\n"
        "                RPOP\n"
        "                RET\n"
        "WBTRUE          DC      'TRUE'    ; Define 'TRUE' constant.\n"
        "WBFALSE         DC      'FALSE'   ; Define 'FALSE' constant.\n"

        // Line writing function to output a newline and manage buffer.
        "WRITELINE       RPUSH\n"
        "                LD      gr7, OBUFSIZE\n"
        "                LD      gr6, NEWLINE\n"
        "                ST      gr6, OBUF,gr7  ; Store newline in buffer.\n"
        "                ADDA    gr7, ONE  ; Increment buffer size.\n"
        "                ST      gr7, OBUFSIZE  ; Update buffer size.\n"
        "                OUT     OBUF, OBUFSIZE  ; Output buffer content.\n"
        "                ST      gr0, OBUFSIZE  ; Reset buffer size.\n"
        "                RPOP\n"
        "                RET\n"

        // Flush function to ensure all data is written out.
        "FLUSH           RPUSH\n"
        "                LD      gr7, OBUFSIZE  ; Check current buffer size.\n"
        "                JZE     FL1          ; If zero, skip flushing.\n"
        "                CALL    WRITELINE    ; Otherwise, flush buffer.\n"
        "FL1             RPOP\n"
        "                RET\n"

        // Character reading function, handling pushback buffer.
        "READCHAR        RPUSH\n"
        "                LD      gr5, RPBBUF  ; Check if there is a character in pushback buffer.\n"
        "                JZE     RC0          ; If not, read new character.\n"
        "                ST      gr5, 0,gr1   ; Store pushback character at specified memory address.\n"
        "                ST      gr0, RPBBUF  ; Clear pushback buffer.\n"
        "                JUMP    RC3          ; Return after handling pushback.\n"
        "RC0             LD      gr7, INP     ; Load input position indicator.\n"
        "                LD      gr6, IBUFSIZE; Load input buffer size.\n"
        "                JNZ     RC1          ; If buffer not empty, proceed to read character.\n"
        "                IN      IBUF, IBUFSIZE  ; Refresh input buffer from external source.\n"
        "                LD      gr7, gr0     ; Reset input position.\n"
        "RC1             CPA     gr7, IBUFSIZE; Compare current position with buffer size.\n"
        "                JNZ     RC2          ; If not at end, read character from buffer.\n"
        "                LD      gr5, NEWLINE ; If at end, assume newline character.\n"
        "                ST      gr5, 0,gr1   ; Store newline in specified memory location.\n"
        "                ST      gr0, IBUFSIZE; Reset buffer size to indicate empty.\n"
        "                ST      gr0, INP     ; Reset input position.\n"
        "                JUMP    RC3          ; Return after handling end of input.\n"
        "RC2             LD      gr5, IBUF,gr7; Load character from buffer at current position.\n"
        "                ADDA    gr7, ONE     ; Increment position in input buffer.\n"
        "                ST      gr5, 0,gr1   ; Store loaded character at specified memory address.\n"
        "                ST      gr7, INP     ; Update input position.\n"
        "RC3             RPOP\n"
        "                RET\n"

        // Integer reading function, handling whitespace and converting numeric input.
        "READINT         RPUSH\n"
        "RI1             CALL    READCHAR  ; Read a character.\n"
        "                LD      gr7, 0,gr1 ; Load the character into gr7.\n"
        "                CPA     gr7, SPACE ; Skip whitespace characters.\n"
        "                JZE     RI1\n"
        "                CPA     gr7, TAB\n"
        "                JZE     RI1\n"
        "                CPA     gr7, NEWLINE\n"
        "                JZE     RI1\n"
        "                LD      gr5, ONE  ; Set flag for positive numbers.\n"
        "                CPA     gr7, MINUS ; Check if the character is a minus sign.\n"
        "                JNZ     RI4        ; If not, start processing digits.\n"
        "                LD      gr5, gr0  ; Set flag for negative numbers.\n"
        "                CALL    READCHAR  ; Read next character.\n"
        "                LD      gr7, 0,gr1 ; Load the next character.\n"
        "RI4             LD      gr6, gr0  ; Initialize integer value.\n"
        "RI2             CPA     gr7, ZERO ; Check if character is between '0' and '9'.\n"
        "                JMI     RI3\n"
        "                CPA     gr7, NINE\n"
        "                JPL     RI3\n"
        "                MULA    gr6, TEN  ; Multiply current integer value by 10.\n"
        "                ADDA    gr6, gr7\n"
        "                SUBA    gr6, ZERO ; Add current digit to integer value.\n"
        "                CALL    READCHAR  ; Read next character.\n"
        "                LD      gr7, 0,gr1 ; Load the next character.\n"
        "                JUMP    RI2       ; Continue processing input.\n"
        "RI3             ST      gr7, RPBBUF; Store last read character for pushback.\n"
        "                ST      gr6, 0,gr1 ; Store final integer value.\n"
        "                CPA     gr5, gr0  ; Check if number is negative.\n"
        "                JNZ     RI5       ; If not negative, finish processing.\n"
        "                SUBA    gr5, gr6  ; Negate the integer value.\n"
        "                ST      gr5, 0,gr1 ; Store negated integer value.\n"
        "RI5             RPOP\n"
        "                RET\n"

        // Skip input until a newline is encountered.
        "READLINE        ST      gr0, IBUFSIZE\n"
        "                ST      gr0, INP\n"
        "                ST      gr0, RPBBUF\n"
        "                RET\n"

        // Constants for various operations.
        "ONE             DC      1\n"
        "SIX             DC      6\n"
        "TEN             DC      10\n"
        "SPACE           DC      #0020  ; ASCII space character.\n"
        "MINUS           DC      #002D  ; ASCII minus character.\n"
        "TAB             DC      #0009  ; ASCII tab character.\n"
        "ZERO            DC      #0030  ; ASCII '0'.\n"
        "NINE            DC      #0039  ; ASCII '9'.\n"
        "NEWLINE         DC      #000A  ; ASCII newline character.\n"

        // Buffer definitions for handling input and output.
        "INTBUF          DS      8\n"
        "OBUFSIZE        DC      0\n"
        "IBUFSIZE        DC      0\n"
        "INP             DC      0\n"
        "OBUF            DS      257\n"
        "IBUF            DS      257\n"
        "RPBBUF          DC      0\n"
    );
}